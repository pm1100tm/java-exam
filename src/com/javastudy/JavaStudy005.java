package com.javastudy;

class TestClass {
    int x = 10;
}

public class JavaStudy005 extends TestClass{
    int x = 20;
    private void testMethod(){
        System.out.println("===");
        System.out.println(x); // 20
        System.out.println(this.x); // 20
        System.out.println(super.x); // 10
    }  
    
    public static void main(String[] args) {
        JavaStudy005 test = new JavaStudy005();
        test.testMethod();
        System.out.println("===");
        /* Class */
        /* 객체지향1
        * 코드의 재사용성
        * 코드의 관리
        * 신뢰성 높은 프로그램 개발(제어자, 메서드 사용하여 데이터를 보호하고, 코드의 중복을 제거하여 코드의 불일치로 인한 오류 방지)
        * 클래스란 - 객체를 정의해 놓은 것.
        * 용도 - 객체를 생성하는데 사용됨.
        * 정의 - 실제로 존재하는 것. 사물 또는 개념.
        * 객체의 용도 - 객체의 속성과 기능에 따라 다름.
        * 
        * 객체와 인스턴스
        * 객체는 인스턴스를 포함하는 일반적인 의미
        * 인스턴스화
        * 클래스로부터 인스턴스를 생성하는 것
        * 
        * 객체의 구성요소 - 속성과 기능.
        * 
        * 인스턴스의 생성과 사용
        * 클래스명 참조변수명; // 객체를 다루기 위한 참조변수 선언
        * 참조변수명 = new 클래스명(); // 객체를 생성 후, 생성된 객체의 주소를 참조변수에 저장
        * 
        * 클래스의 또 다른 정의
        * 1. 클래스 - 데이터와 함수의 결합
        * 변수 - 하나의 데이터를 저장할 수 있는 공간
        * 배열 - 같은 타입의 여러 데이터를 저장할 수 있는 공간
        * 구조체 - 타입에 관계없이 서로 관련된 데이터들을 저장할 수 있는 공간
        * 클래스 - 데이터와 함수의 결합 (구조체 + 함수)
        **/
        
        /* 객체지향2
        * 선언위치에 따른 변수의 종류
        * 변수의 선언 위치가 종류와 범위를 결정한다.
        *   변수의 종류   선언 위치   생성시기
        * - 클래스 변수   클래스 안   클래스가 메모리에 올라갈 때
        * - 인스턴스 변수  클래스 안   인스턴스 생성 시
        * - 지역 변수     메서드 영역  변수 선언문 수행 시
        * 
        * 인스턴스 변수
        * 각 인스턴스의 개별적인 저장 공간. 인스턴스 마다 다른 값 저장 가능
        * 인스턴스 생성 후, 참조 변수, 인스턴스 변수명으로 접근 가능
        * 인스턴스를 생성할 때 생성되고, 참조변수가 없을 때 가비지컬렉터에 의해 자동으로 제거 된다.
        * 
        * 클래스 변수
        * 같은 클래스의 모든 인스턴스들이 공유하는 변수
        * 인스턴스 생성 없이 클래스 이름. 클래스 변수명으로 접근 가능.
        * 클래스가 로딩될 때 생성되고 프로그램이 종료될 때 소멸
        * 
        * 지역 변수
        * 메서드 내에 선언되며, 메서드의 종료와 함께 소멸
        * 조건문, 반복문의 블럭 내에 선언된 지역변수는 블럭을 벗어나면 소멸
        * 
        * return 문 주의 사항
        * - return 문의 개수는 최소화하는 것이 좋다.
        * 
        * JVM 의 메모리 구조
        * 메서드 영역 (method area)
        * - 클래스 정보와 클래스 변수가 저장되는 곳
        * 
        * 호출 스택 (call stack)
        * - 메서드의 작업공간. 메서드가 호출되면 메서드 수행에 필요한 메모리 공간을 할당받고, 메서드가 종료되면
        * 사용하던 메모리를 반환한다.
        * 
        * 힙 (heap)
        * - 인스턴스가 생성되는 공간. new 연산자에 의해서 생성되는 배열과 객체는 모두 여기에 생성된다.
        * 
        * 호출스택 특징
        * -메서드가 호출되면 수행에 필요한 메모리를 스택에 할당 받는다.
        * -메서드가 수행을 마치면 사용했던 메모리를 반환한다.
        * -호출스택의 제일 위에 있는 메서드가 현재 실행중인 메서드이다.
        * -아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드이다.
        * 
        * 클래스 메서드와 인스턴스 메서드
        * 인스턴스 메서드 - 참조변수.메서드이름()
        * 클래스 메서드(static) - 클래스이름.메서드이름() 
        * 
        * *메서드 내에서 인스턴스 변수를 사용하지 않는다면 static 을 붙이는 것을 고려한다.
        * 
        * 메서드 오버로딩
        * - 하나의 클래스에 같은 이름의 메서드를 여러 개 정의하는 것을 오버로딩이라고 한다.
        * - 오버로딩의 조건
        *   - 메서드 이름이 같아야 한다.
        *   - 매개변수 개수 또는 타입이 달라야 한다. 
        *   - 매개 변수는 같고 리턴 타입이 다른 경우는 오버로딩이 성립되지 않는다.
        *   (리턴 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다)
        *   - 매개 변수의 이름이 다른 것은 오버로딩이 아니다.
        *   - 리턴 타입은 오버로딩 성립조건이 아니다.
        * **/
        
        /* 생성자 
        * 인스턴스가 생성될 때 마다 호출되는 인스턴스 초기화 메서드
        * 인스턴스 변수의 초기화 또는 인스턴스 생성시 수행할 작업에 사용
        * 몇 가지 조건을 제외하고는 메서드와 같다.
        * 모든 클래스에는 반드시 하나 이상의 생성자가 있어야 한다.
        * 
        * 생성자의 조건
        * 생성자의 이름은 클래스의 이름과 같다.
        * 생성자는 리턴 값이 없다. 하지만 void 를 쓰지 않는다.
        * 이것 역시 오버로딩. 하나의 클래스에서 여러 개의 생성자를 정의해야 하는 경우 오버로딩의 규칙을 따라야 한다.
        * 
        * 기본 생성자
        * 매개 변수가 없는 생성자.
        * 클래스에 생성자가 하나도 없다면 컴파일러 기본 생성자를 추가한다.
        * 생성자가 하나라도 있다면 컴파일러는 기본 생성자를 추가하지 않는다.
        * **/ 

        /* 접근 제한자
        * public - 전부 공유
        * protected - 타 패키지 내의 상속관계에 있는 클래스들 및 동일 클래스 내에서 공유
        * private - 같은 클래스 내에서만 공유
        * default(friendly) - 같은 패키지 내에서만 공유. 보통 지정자는 생략
        * 
        * default - 키워드를 적지 않을 때. 명시적으로 default 를 적어줄 때
        * 기본 접근 제한자는 클래스, 메서드, 변수 선언을 할 때 명시하지 않으면 기본적으로 적용되는 제한  범위.
        * 같은 패키지 내의 모든 클래스에서 사용 가능.
        * interface 메서드와 변수에는 사용할 수 없다.
        * 
        * private 
        * 메서드, 변수, 생성자를 private 로 선언하면 오직 해당 클래스 내에서만 사용 가능하게 된다.
        * 가장 엄격하게 관리되는 레벨. 클래스와 interface 에는 private 를 쓸 수 없다.
        * 클래스와 interface 를 private 로 선언하면 당연히 사용할 수 없는 클래스와 interface 가 되기 때문이다.
        * 변수를 private 로 선언하면 현재 클래스를 벗어나면 사용할 수 없게 된다.
        * 
        * public
        * 클래스, 메서드, 생성자, interface 등은 모듬 클래스에서 접근 가능하게 하기 위해 public 접근 제한자를 사용.
        * 단, 다른 패키지 내의 클래스를 사용하기 위해서는 해당 클래스를 import 한 뒤에 사용한다.
        * 클래스를 상속하게 되면 public 으로 지정된 메서드, 변수를 하위 클래스에서 모두 사용 가능하게 된다.
        * 하나의 .java 파일 내에는 하나의 public 클래스만 정의할 수 있다. 
        * 또한 java 파일 명과 public 클래스 명은 동일 해야 한다.
        * 
        * protected
        * protected 로 선언된 변수, 메서드, 생성자는 동일 클래스, 동일 패키지, 혹은 상소관계로 연결된 타 패키지의
        * 하위 클래스에서 접근 가능하다.
        * protected 제한자는 클래스와 인터페이스에는 사용할 수 없다.
        * 때문에, 메서드와 변수를 protected 로 선언 가능하지만, interface 내의 메서드와 변수는 지정 불가.
        * protected 제한자는 관계없는 클래스에서 인스턴스 변수, 인스턴스 메서드를 접근 못하도록 보호할 목적으로 사용한다.
        * **/
        
        /* 변수의 초기화
        * 선언하고 처음으로 값을 저장하는 것
        * 멤버 변수 (인스턴스 변수, 클래스 변수) 와 배열은 각 타입이 기본 값으로 자동으로 초기화되므로 초기화를 생략할 수 있다.
        * 지역 변수는 사용하기 전에 꼭 초기화를 해줘야 한다.
        *  **/
        
        /* 초기화 블럭
        * 클래스 초기화 블럭 - 클래스 변수의 복잡한 초기화에 사용되며 클래스가 로딩될 때 실행됨.
        * 인스턴스 초기화 블럭 - 생성자에서 공통적으로 수행되는 작업에 사용되며, 인스턴스가 생성될 때 마다 사용된다. (생성자 보다 먼저)
        * 
        * class InitBlock {
        *   static {
        *       // 클래스 초기화 블럭
        *   }
        * 
        *   { // 인스턴스 초기화 블럭 }
        * }
        * 
        * 멤버 변수의 초기화 시기와 순서
        * 클래스 변수의 초기화 시점 - 클래스가 처음 로딩될 때 한 번
        * 인스턴스 변수 초기화 시점 - 인스턴스가 생성될 때 마다
        *  **/
        
        /* 오버로딩 VS 오버라이딩
        * 오버로딩 - 기존에 없는 메서드를 정의하는 것
        * 오버라이딩 - 상속받은 메서드의 내용을 변경하는 것
        * **/
        
        /* super 와 this
        * this - 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어있음.
        * 모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재.
        * 
        * super - this 와 같다. 조상의 멤버와 자신의 멤버를 구별하는데 사용한다.
        * 자손클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 합쳐진 하나의 인스턴스가 생성된다.
        * 조상의 멤버들도 초기화되어야 하기 때문에 자손의 생성자의 첫 문장에서 조상의 생성자를 호출해야 한다.
        * **/
        
        /* 패키지
        * 서로 관련된 클래스와 인터페이스 묶음
        * 패키지는 물리적으로 폴더이다. 패키지는 서브패키지를 가질 수 있으며, . 으로 구분한다.
        * 클래스의 실제 이름은 패키지명이 포함된 것이다.
        * 모든 클래스는 하나의 패키지에 속하며, 패키지가 선언되지 않은 클래스는 자동적으로 이름없는 (unnamed) 패키지에 속하게 된다.
        * 
        * 클래스패스 classpath 설정
        * 클래스패스는 클래스 파일(.class) 를 찾는 경로이다. 구분자는 ;
        * 클래스패스에 패키지가 포함된 폴더나 jar 파일을 .jar 나열한다.
        * 클래스패스가 없으면 자동적으로 현재 폴더가 포함되지만 클래스패스를 지정할 때는 현재 폴더 . 도 함께 추가해주어야 한다.
        * **/
        
        /* static
        * 멤버 변수, 메서드, 초기화 블럭에 사용될 수 있다.
        * 
        * 멤버변수에 사용했을 시
        * - 모든 인스턴스에 공통적으로 사용되는 클래스 변수가 된다.
        * - 클래스 변수는 인스턴스를 생성하지 않고도 사용 가능.
        * - 클래스가 메모리에 로드될 때 생성된다.
        * 
        * 메서드에 사용했을 시
        * - 인스턴스를 생성하지 않고도 호출 가능하다.
        * - static 메서드 내에서는 인스턴스 멤버들을 직접 사용할 수 없다.
        * **/
        
        /* final 
        * 클래스 - 변경될 수 없는 클래스, 확장될 수 없는 클래스가 된다.
        * final 로 지정된 클래스는 다른 클래스의 조상이 될 수 없다.
        * 
        * 메서드 - 변경될 수 없는 메서드. final 로 지정된 메서드는 오버라이딩
        * 을 통해 재정의 될 수 없다.
        * 
        * 멤버 변수, 지역 변수
        * - 변수 앖에 final 이 붙으면, 값을 변경할 수 없는 상수가 된다.
        * **/
        
        /* abstract 추상의, 미완성의
        * 클래스, 메서드에서 사용됨
        * 클래스 - 클래스 내에 추상 메서드가 선언되어 있음을 의미한다.
        * 메서드 - 선언부만 작성하고 구현부는 작성하지 않는 추상 메서드임을 알린다.
        * **/
        
        /* 접근제어자
        * 멤버 또는 클래스에 사용되어, 외부로부터의 접근을 제한한다.
        * private - 같은 클래스 내에서만 접근 가능하다.
        * default - 같은 패키지 내에서만 접근 가능하다.
        * protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손 클래스에서 접근 가능한다.
        * public - 접근 제한이 없다.
        * 
        * 접근 제어자를 사용하는 이유
        * - 외부로부터의 데이터를 보호하기 위해서 
        * - 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서
        * 
        * 생성자의 접근 제어자
        * - 일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치한다.
        * - 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다.
        * 
        * 제어자의 조합
        * 1. 메서드에 static 과 abstract 를 함께 사용할 수 없다.
        * - static 메서드는 몸통(구현부)이 있는 메서드에만 사용할 수 있기 때문이다.
        * 2. 클래스에 abstract 와 final 을 동시에 사용할 수 없다.
        * - 클래스에 사용되는 final 은 클래스를 확장할 수 없다는 뜻이고, abstract 는 상속을 통해서
        * 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
        * 3. abstract 메서드의 접근제어가자 private 일 수 없다.
        * - 추상 메서드는 자손 클래스에서 구현해주어야 하기 때문에
        * 4. 메서드에 private 와 final 을 같이 사용할 필요는 없다. 
        * 접근 제어자가 private 인 메서드는 오버라이딩 될 수 없기 때문이다. 
        * 이 둘 중 하나만 사용해도 의미가 충분하다.
        * **/ 
        
        /* 다형성
        * 여러 가지 형태를 가질 수 있는 능력
        * 하나의 참조변수로 여러 타입의 객체를 참조할 수 있는 것. 
        * 즉, 조상 타입의 참조변수로 자손 타입의 객체를 다룰 수 있는 것이 다형성
        * 조상 타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있지만,
        * 반대로 자손 타입의 참조변수로 조상 타입의 인스턴스를 참조할 수는 없다.
        * 
        * 참조변수의 형변환
        * - 서로 상속관계에 있는 타입간의 형변환만 가능하다.
        * - 자손 타입에서 조상타입으로 형변환하는 경우, 형변환 생략 가능하다.
        * **/
        
        /* 추상클래스
        * 미완성 설계도
        * 추상메서드 - 미완성 메서드를 포함하고 있는 클래스
        * 일반 메서드가 추상메서드를 호출할 수 있다.
        * 완성된 설계도가 아니므로 인스턴스를 생성할 수 없다.
        * 다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다.
        *
        * 추상메서드란
        * 선언부만 있고 구현부(몸통, body) 가 없는 메서드
        * 꼭 필요하지만 자손마다 다르게 구현될 것으로 예상되는 경우에 사용
        * 추상클래스를 상속받는 자손클래스에서 추상메서드의 구현부를 완성해야 한다.
        * 
        * 추상 클래스의 작성
        * 여러 클래스에서 공통적으로 사용될 수 있는 추상클래스를 바로 작성하거나
        * 기존 클래스의 공통 부분을 뽑아서 추상클래스를 만든다.
        *  **/
        
        /* 인터페이스
        * 일종의 추상클래스. 추상클래스보다 추성화 정도가 높다.
        * 실제 구현된 것이 전혀 없는 기본 설계도 (알맹이 없는 껍데기)
        * 추상메서드와 상수만을 멤버로 가질 수 있다.
        * 인스턴스를 생성할 수 없고, 클래스 작성에 도움을 줄 목적으로 사용된다.
        * 미리 정해진 규칙에 맞게 구현하도록 표준을 제시하는데 사용된다.
        * 
        * interface InterfaceName (
        *   public static final 타입 상수이름 = 값;
        *   public abstract 메서드이름 (매개변수목록);
        * )
        * 
        * 구성요소(멤버)는 추상메서드와 상수만 가능하다.
        * public static final 이어야 하며, 생략할 수 있다.
        * 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
        * 
        * 인터페이스도 클래스처럼 상속이 가능하다 (클래스와 달리 다중상속 허용)
        * interface Movable(
        *   void move(int x, int y);
        * )
        * 
        * interface Attackable(
        *   void attack(Unit u);
        * )
        * 
        * interface Fightable extends Movable, Attackable {}
        * 
        * 인터페이스는 Object 클래스와 같은 최고 조상이 없다.
        * 
        * 인터페이스의 구현
        * - 클래스를 상속받는 것과 같다. implements 를 사용한다.
        * - 인터페이스에 정의된 추상메서드를 완성해야 한다.
        * - 상속과 구현이 동시에 가능하다.
        * 
        * 인터페이스를 이용한 다형성
        * - 인터페이스 타입의 변수로 인터페이스를 구현한 클래스의 인스턴스를 참조할 수 있다.
        * - 인터페이스를 메서드의 매개변수 타입으로 지정할 수 있다.
        * - 인터페이스를 메서드의 리턴타입으로 지정할 수 있다.
        * 
        * 디폴트 메서드 JDK 1.8 에 추가
        * 
        * 인터페이스는 좀 더 깊게 파보도록 하자.
        * **/
        
        /* 내부 클래스
        * 클래스 안에 선언된 클래스
        * 특정 클래스 내에서만 주로 사용되는 클래스를 내부 클래스로 선언한다.
        * GUI 어플리케이션 AWT, Swing 의 이벤트처리에 주로 사용된다.
        * 
        * 장점 
        * - 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
        * - 코드의 복잡성을 줄일 수 있다. (캡슐화)
        * class A {}
        * class B {}
        * class A {
        *   ...
        *   class B {
        *       ...
        *   }
        * }
        * 
        * 내부 클래스의 종류와 특징
        * - 내부 클래스의 종류는 변수의 선언위치에 따른 종류와 동일
        * - 유효범위와 성질도 변수와 유사하므로 비교해보면 이해하기 쉽다.
        * 
        * 내부 클래스, 익명 클래스 좀 더 깊게 봐보자. 일단 진도를 나가기로 한다.
        * **/
    }
}
